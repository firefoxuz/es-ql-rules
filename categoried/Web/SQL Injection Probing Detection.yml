rule_id: bace5816-33e3-4717-a8ce-6aaa8b0e1da1
name: "SQL Injection Probing Detection"
description: |
  This rule identifies SQL injection (SQLi) attack attempts in HTTP requests by analyzing nginx access logs for common SQLi patterns in URI parameters and request bodies. It detects classic SQLi signatures such as UNION SELECT statements, comment sequences (--,/*,#), boolean-based blind SQLi (AND 1=1, OR 1=1), time-based blind techniques (SLEEP, WAITFOR), and stacked queries. The rule triggers when 5+ distinct SQLi patterns are detected from a single source IP within 10 minutes.

#**Why it matters:**
#SQL injection remains one of the most critical web application vulnerabilities:
#- OWASP Top 10 #3 (Injection) - leads to data breaches and complete system compromise
#- PCI DSS 6.5.1 explicitly requires protection against injection flaws
#- GDPR Article 32 mandates safeguards against SQL injection as a common attack vector#
#**False Positives:**
#- Security scanners performing authorized vulnerability assessments
#- Web application firewalls or security tools testing their own SQLi signatures
#- Developers testing SQLi defenses in development/staging environments
#- Legitimate search queries containing SQL-like syntax (rare but possible)#
#**Triage Steps:**
#1. Verify source IP - is it from authorized security scanning infrastructure?
#2. Review targeted endpoints to identify vulnerable parameters or applications
#3. Check application logs for actual SQL errors or unusual database queries
#4. Test if any SQLi attempts succeeded by reviewing response codes and sizes
#5. Validate web application firewall rules are properly blocking these patterns
#6. Conduct code review of targeted endpoints for SQLi vulnerabilities
type: esql
params: '{}'
schedule_interval: 10m
index:
  - filebeat-nginx-access-*
query_language: esql
query: |
  FROM filebeat-nginx-access-*
  // Time window: last 10 minutes
  | WHERE @timestamp >= NOW() - 10 minutes
  // Extract source IP and request info
  | EVAL srcip = COALESCE(source.ip, "")
  | EVAL uri = event.original
  | WHERE srcip IS NOT NULL AND uri IS NOT NULL
  // SQL injection pattern detection
  | WHERE uri RLIKE ".*( UNION | union |SELECT |select |INSERT |insert |UPDATE |update |DELETE |delete |--|/\\*|;--|' OR | or 1=1| and 1=1|SLEEP\\(|WAITFOR |BENCHMARK\\(|pg_sleep|EXTRACTVALUE\\(|UPDATEXML\\().*"
  // Aggregate by source IP
  | STATS 
      request_count = COUNT(*),
      unique_patterns = COUNT_DISTINCT(SUBSTRING(uri, 0, 160)),
      sample_requests = VALUES(SUBSTRING(uri, 0, 160))
    BY srcip
  // Threshold: 5+ distinct SQLi patterns
  | WHERE unique_patterns >= 5
  // Risk scoring
  | EVAL risk_score = CASE(
      request_count >= 50, 90,
      request_count >= 20, 80,
      70
    )
  | KEEP srcip, request_count, unique_patterns, risk_score, sample_requests
enabled: false
tags:
  - Web Security
  - SQL Injection
  - OWASP
  - Initial Access
  - Injection Attack
severity: high
risk_score: 80
references:
  - "https://owasp.org/www-community/attacks/SQL_Injection"
  - "https://attack.mitre.org/techniques/T1190/"
nist: ["SI-10", "SI-4"]
gdpr: ["Article 32"]
pci_dss: ["6.5.1", "11.4"]
mitre_attack:
  TA0001:
    T1190: []